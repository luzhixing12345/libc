
# vfs

文件系统中存储的最小单位是块(Block), 块的大小是在格式化的时候确定的, 例如 mke2fs -b 指定设定块的大小为 1024/**4096**

![20230423160821](https://raw.githubusercontent.com/learner-lu/picbed/master/20230423160821.png)

上图是 ext2 文件系统的格式, 其中启动块 Boot Block 大小1KB, 由PC标准规定, 用来存储磁盘分区信息和启动信息, 在任何文件系统中都不会使用该块. 接下来是连续的块组 Block Group X, 每一个 Block 的组织结构相同

超级块(super block) 描述整个分区的文件系统信息, 例如 **块大小**, 文件系统版本号, 上次 mount 的时间等等, 超级块在每个块组的开头都会保存一份

块组描述符表(GDT,Group Descriptor Table) 由很多块组描述符组成,整个分区分成多少个块组就对应有多少个块组描述符.**每个块组描述符存储一个块组的描述信息**,[包括inode表哪里开始,从哪里开始,空闲的inode和数据块还有多少个等等].块组描述符表在每个块组的开头也都一份拷贝,及些信息是非常重要的,因此它们都有多份拷贝.

块位图(block bitmap) 用来描述整个块组中哪些块已用, 哪些块空闲, 本身占一个块, 其中每个bit代表一个块

inode位图(inode bitmap) 同块位图, 用于表示 inode 是否空闲可用

**inode表(inode table)** 文件类型 权限 文件大小 创建/修改/访问时间等信息, 每个文件都有一个 inode

**数据块(data block)**

- 常规文件: 文件的数据存储在数据块中
- 目录: 目录下的所有文件名和目录名存储在数据块中(**文件名保存在它所在目录的数据块中**, 文件的其他信息保存在该文件的inode中)
- 符号链接: 如果目标路径名较短则直接保存在inode中以便更快的查找, 否则分配一个数据块来保存
- 设备文件 FIFO socket等特殊文件: 没有数据块, 设备文件的主设备号和次设备号保存在 inode 中

> 例如一个文件名为 test.txt, 文件内容是 "hello\n", 那么文件内容 "hello\n" 保存在数据块中, 文件的相关信息保存在inode表中, 文件名 test.txt 保存在其所在目录的数据块中
>
> 当我们输入 vim /home/a.txt 的时候,这是一个递归的搜索过程.  首先从根目录 `/` 查找数据块, 找到 home, 数据块中保存着该目录的inode地址, 再访问这个 inode 地址, 根据 home 的inode地址访问home的数据块, 找到 a.txt, 这个数据块中保存着 a.txt 的inode地址, 再根据a.txt的inode地址访问这个文件的inode, a.txt 的 inode的数据块中就是这个文件的所有内容了

Linux支持各种各样的文件系统格式,然而这些文件系统都可以mount到某个目录下,使我们看到一个统一的目录树,各种文件系统上的目录和文件我们用 ls命令看起来是一样的,读写操作用起来也都是一样的,这是怎么做到的呢? Linux内核在各种不同的文件系统格式之上做了一个抽象层,使得文件、目录、读写访问等概念成为抽象层的概念,因此各种文件系统看起来用起来都一样,这个抽象层称为虚拟文件系统(VFS,VirtualFilesystem).

